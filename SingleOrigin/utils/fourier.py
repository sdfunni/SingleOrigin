"""Module containing utility functions performing Fourier Transforms."""

import numpy as np
from numpy.linalg import norm

from scipy.optimize import minimize

from scipy.ndimage import (
    gaussian_filter,
    center_of_mass,
    label,
)
from scipy.fft import (
    fft2,
    ifft2,
    fftshift,
)


from SingleOrigin.utils.peakfit import detect_peaks

from SingleOrigin.utils.image import cross_correlation

# %%


def fft_square(
    image,
    hann_window=False,
    upsample_factor=None,
    abs_val=True,
    preshift=False,
    postshift=True,
    single_precision=False
):
    """Gets FFT with equal x & y pixel sizes

    Parameters
    ----------
    image : ndarray
        The image or image stack. May be an image stack or 4D array of images
        (e.g. a 4D dataset of diffraction patterns, 4D STEM). The FFT will
        be taken along the last two axes.

    hann_window : bool
        Whether to apply a hanning window to the image before taking the FFT.
        Default: False

    upsample_factor : int
        The factor by which to upsample the data during the FFT process. This
        operation is done by padding the image(s) with zeros after applying
        the (optional) Hanning window. Hanning windowing is recommended to
        avoid artifacts if upsampling. For 4D STEM datasets, using large
        factors can be very slow and may max out available memory.
    abs_val : bool
        Whether to take return the absolute value of the FFT (if True). If
        False, returns the complex-valued FFT.
        Default: True

    preshift : bool
        Whether to apply fftshift prior to taking the FFT. Needed for imaginary
        cepstrum.
        Default: False

    postshift : bool
        Whether to apply fftshift after taking the FFT. Commonly used to
        display the zero frequency at the center.
        Default : True

    single_precision : bool
        Whether to use 'single' (float32/complex64) rather than 'double'
        (float64/complex128) precision floating point data types. Running
        cepstrum transforms on large 4D STEM datasets can be much faster using
        'single' precision with no loss of information.
        Default: False

    Returns
    -------
    fft : ndarray
        FFT amplitude of image after cropping to largest possible square image.

    """

    h, w = image.shape[-2:]
    m = min(h, w)
    U = m/2
    ndim = len(image.shape)

    if single_precision:
        dtype_float = np.float32
        dtype_complex = np.complex64
    else:
        dtype_float = np.float64
        dtype_complex = np.complex128

    if h != w:
        image_square = image[...,
                             int(h/2-U): int(h/2+U),
                             int(w/2-U): int(w/2+U)]
    else:
        image_square = image

    if type(hann_window) is bool:
        if hann_window:
            hann = np.expand_dims(
                hann_2d((m, m)),
                axis=tuple(i for i in range(ndim - 2))
            )

            image_square = image_square * hann

    elif type(hann_window) is np.ndarray:
        image_square = image_square * hann_window

    if upsample_factor is not None:
        if upsample_factor > 1:
            print('upsampling... may take a while longer.')
            upsample_factor = int(upsample_factor)
            pad = int(m/2 * (upsample_factor - 1))
            padding = ((0, 0),)*(ndim - 2) + ((pad, pad),)*2
            image_square = np.pad(image_square, padding)

    if preshift:
        fft = fft2(fftshift(image_square, axes=(-2, -1))).astype(
            dtype=dtype_complex)
    else:
        fft = fft2(image_square).astype(dtype=dtype_complex)

    if postshift:
        fft = fftshift(fft, axes=(-2, -1))
    if abs_val:
        fft = np.abs(fft, dtype=dtype_float)
    return fft


def hann_2d(shape):
    """
    Create a 2D Hann window without square artifact generated by the common
    method.

    The resulting Hann function is round / elliptical depending on input shape.

    Parameters
    ----------
    shape : 2-tuple
        Dimensions of the window to be created.

    Returns
    -------
    hann : 2d array
        The Hann window.

    """

    inds = np.indices(shape)

    origin = np.array(shape) // 2

    r = np.linalg.norm(
        inds - origin[:, None, None],
        axis=0
    ) * 2*np.pi / np.min(shape)

    hann = np.where(r > np.pi, 0, np.cos(r) + 1) / 2

    return hann


def hann1d_taper(shape, n_taper):
    """Calculate a hann taper mask for a 1D array over a given number of pixels
    at each end.

    Parameters
    ----------
    shape : int
        Length of 1D array.

    n_taper : scalar
        Number of pixels to taper at each end of the array.

    Returns
    -------
    hann_taper : 1D array
        Hann taper mask array with values between [0, 1].

    """

    origin = (np.array(shape)) / 2
    dists = (origin - np.abs((np.arange(shape)) - origin)) / n_taper
    dists = np.pi * np.where(dists > 1, 1, dists) - np.pi/2
    hann_taper = (np.sin(dists) + 1) / 2

    return hann_taper


def get_fft_pixel_size(image, pixel_size):
    """Calculate FFT pixel size for an image.

    Parameters
    ----------
    image : 2D array
        The image. If not square, the smaller dimension will be used.

    pixel_size : scalar
        The pixel size of the real space image.

    Returns
    -------
    reciprocal_pixel_size : scalar
        Size of a pixel in an FFT of the image (assuming the image is first
        cropped to the largest square).

    """
    h, w = image.shape
    m = (min(h, w) // 2) * 2

    reciprocal_pixel_size = (pixel_size * m) ** -1

    return reciprocal_pixel_size


def cft(xy, image):
    """
    Calculate value of the continuous Fourier tansform of an array at an
    arbitrary point.

    Parameters
    ----------
    xy : 2-tuple of scalars
        The x, y coordinates in the Fourier transform  that are to be sampled.
        x is the horizontal axis, y the vertical (with positive increasing
        down the frame).

    im : 2d array
        The array from which the Fourier transform is to be caluclated.

    Returns
    -------
    val : scalar
        Value of CFT at the point xy
    """

    x, y = xy
    h, w = image.shape
    j = np.arange(h)[:, None]
    k = np.arange(w)[None, :]

    x += w/2  # because the coordinates are zero-centered
    y += h/2

    val = np.sum((image * (np.exp(-2 * np.pi * 1j * j * y / h) @
                           np.exp(-2 * np.pi * 1j * k * x / w))))

    return val


def cepstrum(data, method='power', upsample_factor=1):
    """
    Calculate the exit wave cepstrum of a dataset.

    Parameters
    ----------
    data : ndarray
        The array containing diffraction patterns from which to calculate the
        cepstrum. The last two dimensions must be the diffraction patterns and,
        ideally, they should be square.

    method : str
        The cepstrum type to return: 'power', 'imaginary' or 'complex'.

    upsample_factor : int
        Factor by which to upsample the cepstrum relative to the input data.

    Returns
    -------
    cepstrum : ndarray
        The cepstral transform of the data.
    """

    minval = np.array(np.min(data, axis=(-2, -1)))[..., None, None]

    if method == 'power':
        cepstrum = fft_square(
            np.log(data - minval + 1, dtype=np.float32),
            hann_window=True,
            upsample_factor=upsample_factor,
            abs_val=True,
            preshift=False,
            single_precision=True,
        )

    elif method == 'imaginary':
        cepstrum = np.imag(fft_square(
            np.log(data - minval + 1, dtype=np.float32),
            hann_window=True,
            upsample_factor=upsample_factor,
            abs_val=False,
            preshift=True,
            single_precision=True,
        ))

    elif method == 'complex':
        cepstrum = fft_square(
            np.log(data - minval + 1, dtype=np.float32),
            hann_window=True,
            upsample_factor=upsample_factor,
            abs_val=False,
            preshift=True,
            single_precision=True,
        )

    else:
        raise Exception("'method' must be 'power', 'imagninary' " +
                        "or 'complex'.")

    return cepstrum


def ewpc_obj_fn(xy, log_dp):
    """
    Objective function for EWPC peak finding.

    Parameters
    ----------
    xy : 2-tuple of scalars
        The x, y coordinates in the Fourier transform  that are to be sampled.
        x is the horizontal axis, y the vertical (with positive increasing
        down the frame).

    log_dp : 2d array
        The array from which the Fourier transform is to be caluclated.

    Returns
    -------
    value : scalar
        Negative of the magnitude of the CFT. Allows finding the minimum of
        the inverted EWPC peak (i.e. the positive peak maximum).
    """

    return -np.abs(cft(xy, log_dp))


def find_ewpc_peak(
        p0,
        log_dp,
        bound_dist,
):
    """
    Find a peak in an EWPC pattern.

    Parameters
    ----------
    p0 : 2-tuple of scalars
        Initial guess for the x, y coordinates of the EWPC peak.

    log_dp : 2d array
        Log of the array from which the EWPC is to be calculated, with Hann
        window applied.

    bound_dist : scalar
        The distance in x and y from p0 bounding the allowed solution.

    Returns
    -------
    params : 2-tuple of scalars
        The resulting peak location.
    """

    bounds = ((p0[0] - bound_dist, p0[0] + bound_dist),
              (p0[1] - bound_dist, p0[1] + bound_dist))

    params = minimize(
        ewpc_obj_fn,
        p0,
        args=log_dp,
        bounds=bounds,
        method='L-BFGS-B',
    ).x

    return params


def ewic_peak_obj_fn(xy, log_dp, sign):
    """
    Objective function for EWIC peak finding.

    Parameters
    ----------
    xy : 2-tuple of scalars
        The x, y coordinates in the Fourier transform  that are to be sampled.
        x is the horizontal axis, y the vertical (with positive increasing
        down the frame).

    log_dp : 2d array
        The array from which the Fourier transform is to be caluclated.

    sign : 1 or -1
        The sign of the peak to be fit. i.e. whether it is the postive or
        negative EWIC peak of the dipole being measured.

    Returns
    -------
    value : scalar
        Negative of the magnitude of the CFT. Allows finding the minimum of
        the inverted EWPC peak
    """

    return -1 * np.imag(cft(xy, log_dp)) * sign


def find_ewic_peak(
        p0,
        log_dp,
        bound_dist,
        sign
):
    """
    Find a peak in an EWPC pattern.

    Parameters
    ----------
    p0 : 2-tuple of scalars
        Initial guess for the x, y coordinates of the EWPC peak.

    log_dp : 2d array
        Log of the array from which the EWPC is to be calculated, with Hann
        window applied.

    bound_dist : scalar
        The distance in x and y from p0 bounding the allowed solution.

    sign : 1 or -1
        The sign of the peak to be fit. i.e. whether it is the postive or
        negative EWIC peak of the dipole being measured.

    Returns
    -------
    params : 2-tuple of scalars
        The resulting peak location.
    """

    bounds = ((p0[0] - bound_dist, p0[0] + bound_dist),
              (p0[1] - bound_dist, p0[1] + bound_dist))

    params = minimize(
        ewic_peak_obj_fn,
        p0,
        args=(log_dp, sign),
        bounds=bounds,
        method='L-BFGS-B',
    ).x

    return params


def fourier_center(data, center, coords=None, hann_window=True):
    """
    Center a point in an image.

    This function shifts the image to center the specified coordinate at the
    pixel (h//2, w//2). This is the correct convention so that if fftshift is
    applied, the centered point will be shifted to the (0, 0) pixel.
    Additionally, the function works for image stacks or (higher dimension)
    by appling the shift to the last two axes only.

    Parameters
    ----------
    image : ndarray
        The image to center.

    center : 2-tuple
        The (x, y) coordinates of the image point to be centered.

    coords : array of shape (2, m, n)
        The coordinates of pixels in unshifted FFT space with the components in
        (x, y) order along the first axis. If None, function will calculate the
        coordinates. Only recommended to pass coordinates if calling many times
        to avoid calculating repeatedly.
        Default: None.

    hann_window : bool
        Whether to apply a Hann window before each FFT operation. Significantly
        recudes intensity outside the middle of the dataset.

    Returns
    -------
    im_cent : ndarray
        The centered image.
    """

    # Initial setup
    h, w = data.shape[-2:]

    if coords is None:
        # m = data.shape[-1] // 2
        coords = fftshift(
            np.flip(np.indices(data.shape[-2:]), axis=0),
            axes=(-2, -1)
        )

    if hann_window:
        window = hann_2d((h, w))
    else:
        window = np.ones((h, w))

    shiftxy = np.array([w, h]) // 2 - np.array(center)

    # Shift the image
    cF = fft2(data * window)

    phase = np.exp(
        -1j * 2 * np.pi * (coords[0] * shiftxy[0] + coords[1] * shiftxy[1]) / h
    )

    datashifted = np.abs(ifft2(fftshift(window) * cF * phase))

    return datashifted


def fourier_shift(data, shift, coords=None, hann_window=True):
    """
    My version... may be slower.
    Center a point in an image.

    This function shifts the image to center the specified coordinate at the
    pixel (h//2, w//2). This is the correct convention so that if fftshift is
    applied, the centered point will be shifted to the (0, 0) pixel.
    Additionally, the function works for image stacks or (higher dimension)
    by appling the shift to the last two axes only.

    Parameters
    ----------
    image : ndarray
        The image to center.

    center : 2-tuple
        The (x, y) coordinates of the image point to be centered.

    coords : array of shape (2, m, n)
        The coordinates of pixels in unshifted FFT space with the components in
        (x, y) order along the first axis. If None, function will calculate the
        coordinates. Only recommended to pass coordinates if calling many times
        to avoid calculating repeatedly.
        Default: None.

    hann_window : bool
        Whether to apply a Hann window before each FFT operation. Significantly
        recudes intensity outside the middle of the dataset.

    Returns
    -------
    im_cent : ndarray
        The centered image.
    """

    # Initial setup
    h, w = data.shape[-2:]
    dtype = data.dtype

    if coords is None:
        coords = fftshift(
            np.flip(np.indices(data.shape[-2:]), axis=0),
            axes=(-2, -1)
        )

    if hann_window:
        window = hann_2d((h, w))
    else:
        window = np.ones((h, w))

    # Shift the image
    cF = fft2(data * window)

    phase = np.exp(
        -1j * 2 * np.pi * (coords[0] * shift[0] + coords[1] * shift[1]) / h
    )

    datashifted = np.abs(ifft2(fftshift(window) * cF * phase)).astype(dtype)

    return datashifted


def ewic_center_obj_fn(xy, dp, mask, coords):
    """
    Objective function for finding the centering shift of a diffraction
    pattern using EWIC.

    Parameters
    ----------
    dp : ndarray
        The diffraction pattern.

    xy : 2-tuple or None
        The (x, y) shift to apply.

    mask : ndarray
        Array that masks off all parts of the EWIC pattrern except for
        intense peaks that appear in the EWPC.

    coords : ndarray
        The (x, y) coordinates for each pixel in the dp.

    Returns
    -------

    ewic_ss : scalar
        The sum of squares of the masked EWIC for the given shift.
    """

    dp_cent = fourier_center(dp, xy, coords)

    ewic = cepstrum(dp_cent, method='imaginary')

    ewic_ss = np.sum((ewic * mask)**2)

    return ewic_ss


def find_dp_center_ewicmin(dp, xy0=None, coords=None, shift_limit=None):
    """
    Find the center of a diffraction pattern.

    This function finds the center of a diffraction pattern by determining
    the Fourier shift that produces the smallest residual difference between
    the shifted pattern and its left-right & up-down flips. It works best for
    diffraction patterns that are nearly centered, nearly on-zone and with a
    relatively dominant direct beam.

    Parameters
    ----------
    dp : ndarray
        The diffraction pattern.

    xy0 : 2-tuple or None
        The (x, y) initial guess for the diffraction pattenr center. If None,
        takes the center of mass of the entire pattern as the initial guess.

    coords : ndarray
        The (x, y) coordinates for each pixel in the dp. If None, will be
        calculated by the funciton.
        Default: None.

    shift_limit : scalar
        The maximum allowed shift along x and y from the initial guess in
        pixels.

    Returns
    -------
    xy_cent : 2-tuple
        The center of the diffraction pattern.
    """

    if xy0 is None:
        xy0 = np.flip(center_of_mass(dp))

    if coords is None:
        coords = fftshift(
            np.flip(np.indices(dp.shape[-2:]), axis=0),
            axes=(-2, -1)
        )

    if shift_limit is not None:
        bounds = [(xy0[0] - shift_limit, xy0[0] + shift_limit),
                  (xy0[1] - shift_limit, xy0[1] + shift_limit)]

    else:
        bounds = [(-np.inf, np.inf), (-np.inf, np.inf)]

    ewpc = cepstrum(dp, method='power')
    ewpc_sm = gaussian_filter(ewpc, 1)

    peaksmap = detect_peaks(
        ewpc_sm,
        min_dist=4,
        thresh=0,
        return_DataFrame=False,
    )

    peakvals = np.unique(ewpc_sm * peaksmap)
    ewpc = np.where(ewpc_sm > peakvals[-2], peakvals[-2], ewpc_sm)
    mask = np.where(ewpc_sm > np.mean(ewpc_sm) * 3, 1, 0)

    labels = label(mask)[0]

    mask = np.where(np.isin(labels, [labels[*np.array(dp.shape)//2], 0]), 0, 1)

    fit = minimize(
        ewic_center_obj_fn,
        xy0,
        args=(dp, mask, coords),
        bounds=bounds,
        method='L-BFGS-B',
    )
    xy_cent = fit.x

    return xy_cent


def center_dp_ewic(
        dp,
        xy0,
        coords=None,
        return_shift=False,
        nearest_pixel=False,
        hann_window=True,
        shift_limit=None,
):
    """
    Find shift needed to center an individual diffraction pattern by minimizing
    the imaginary cepstrum, then center the pattern using Fourier shift.

    Parameters
    ----------
    dp : 2d array
        The diffraction pattern.

    xy0 : array like of shape (2,
        The (x, y) initial guess for the diffraction pattern center.

    coords : ndarray
        The (x, y) coordinates for each pixel in the dp. If None, will be
        calculated by the funciton.
        Default: None.

    return_shift : bool
        If true, will return the measured shift for the diffraction pattern
        Default: False.

    nearest_pixel : bool
        Whether to round to the nearest pixel when centering. For EWIC
        polarization analysis, it is better to center exactly, but subpixel
        centering with the Fourier shift method produces diffraction patterns
        with obvious artifacts. The artifacts do not adversely affect EWIC
        analysis, but are undesirable for other analyses.
        Default: False

    hann_window : bool
        Whether to apply a Hann window before each FFT operation when doing the
        final centering. Significantly recudes intensity outside the middle of
        the dataset.

    shift_limit : scalar
        The maximum allowed shift along x and y from the initial guess in
        pixels.

    Returns
    -------
    dp_cent : 2d array
        The centered diffraction pattern.


    """

    if coords is None:
        coords = fftshift(
            np.flip(np.indices(dp.shape[-2:]), axis=0),
            axes=(-2, -1)
        )

    cent = find_dp_center_ewicmin(dp, xy0, coords, shift_limit)

    if nearest_pixel:
        cent = np.around(cent)

    dp_cent = fourier_center(dp, cent, coords, hann_window)

    if return_shift:
        shift = cent - np.flip(dp.shape[-2:]) // 2
        return dp_cent, shift

    else:
        return dp_cent


def align_dp_cc(im, ref, return_shift=False, ):
    """
    Align a single diffraction pattern based on its cross correlation with
    a reference pattern.

    Parameters
    ----------
    im : 2d array
        The image.

    origin : array like of shape (2,)
        The .

    Returns
    -------
    cent : array like of shape (2,)
        Coordinates of the nearest peak measured by center of mass.
    """

    origin = np.array(im.shape[:2]) // 2

    cc = cross_correlation(ref, im)

    _, peaks = detect_peaks(
        cc,
        min_dist=4,
        thresh=0,
        return_DataFrame=True,
    )

    ind = np.argmin(norm(peaks.loc[:, 'x':'y'].to_numpy() - origin, axis=1))

    shift = peaks.loc[ind, 'x':'y'].to_numpy() - origin

    dp_descan = fourier_shift(im, shift, hann_window=False)

    if return_shift:
        return dp_descan, shift
    else:
        return dp_descan

    return dp_descan, shift
