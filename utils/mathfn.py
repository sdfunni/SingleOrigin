"""Module containing basic mathematical models for fitting to data."""

import numpy as np
from numpy import (exp, sin, cos)


# %%


def gaussian_1d(x, x0, sig, A):
    """Sample a 1D Gaussian function.

    Parameters
    ----------
    x : ndarray
        The x coordinates of each sampling point.

    x0 : scalar
        Center coordinate of Gaussian.

    sig : scalar
        Sigma of the Gaussian.

    A : scalar(s)
        Peak amplitude of the Gaussian(s).

    Returns
    -------
    y : ndarray
        the value of the function at the specified points.

    """

    return A*np.exp(-1/2*((x - x0)**2 / sig*2))


def gaussian_2d(x, y, x0, y0, sig_maj, sig_rat, ang, A=1, b=0):
    """Sample a 2D, ellpitical Gaussian function or group of Gaussians.

    Parameters
    ----------
    x, y : ndarrays, must have the same shape
        The x and y coordinates of each sampling point. If given arrays
        generated by numpy.mgrid or numpy.meshgrid, will return an image
        of the Gaussian.

    x0, y0 : scalars
        Center coordinates of Gaussian(s).

    sig_maj : scalar(s)
        Sigma of the major axis of the Gaussian(s).

    sig_ratio : scalar(s)
        Ratio of major to minor axis sigmas of the Gaussian(s).

    ang : scalar(s)
        Rotation angle of the major axis from horizontal for the Gaussian(s).
        In degrees.

    A : scalar(s)
        Peak amplitude of the Gaussian(s).

    b : scalar
        Constant background value for the Gaussian(s).

    Returns
    -------
    z : the value of the function at the specified points. Will have the same
        shape as x, y inputs

    """

    # Add dimensions to ensure functionality for 1 or many Gaussians
    # for var in [x0, y0, sig_maj, sig_rat, ang, A, b]:
    #     if isinstance(var, np.ndarray):
    #         if len(var.shape) == 1:
    #             var = var[..., None]

    # x = np.atleast_2d(x)
    # y = np.atleast_2d(y)
    x = x[None, ...]
    y = y[None, ...]

    ang = np.radians(-ang)  # negative due to inverted y axis
    sig_min = sig_maj / sig_rat

    z = np.sum(A * exp(-0.5 * (
        ((cos(ang) * (x - x0) + sin(ang) * (y - y0)) / sig_maj)**2
        + ((-sin(ang) * (x - x0) + cos(ang) * (y - y0)) / sig_min)**2)),
        axis=0) + b

    return z


def plane_2d(x, y, params):
    """
    Calculate z values for a plane at specified x and y positions.

    Parameters
    ----------
    x, y : ndarrays
        The x and y coordinates at which to calculate the z height of the
        plane. Must be the same shape.

    params : 3-typle of scalars
        The x and y slopes and z-intercept of the plane.

    Returns
    -------
    z : ndarray
        The z values of the plane at the x, y coordinates. Will be the same
        shape as x & y.

    """

    [mx, my, b] = params

    z = mx*x + my*y + b

    return z


def line(x, params):
    """
    Calculate y values for a line at specified x positions.

    Parameters
    ----------
    x : ndarrays
        The x coordinates at which to calculate y value of the
        line.

    params : 2-typle of scalars
        The slope and y-intercept of the line.

    Returns
    -------
    y : array
        The y values of the line at the x coordinates. Will be the same
        shape as x.

    """

    [m, b] = params

    y = m*x + b

    return y
