import psutil

from joblib import Parallel, delayed
from tqdm import tqdm

import numpy as np

from scipy.optimize import minimize

from scipy.ndimage import (
    gaussian_filter,
    # fourier_shift,
    center_of_mass,
)
from scipy.fft import (
    fft2,
    ifft2,
    fftshift,
)


# %%


def fft_square(
    image,
    hann_window=False,
    upsample_factor=None,
    abs_val=True,
    preshift=False,
    postshift=True,
):
    """Gets FFT with equal x & y pixel sizes

    Parameters
    ----------
    image : ndarray
        The image or image stack. May be an image stack or 4D array of images
        (e.g. a 4D dataset of diffraction patterns, 4D STEM). The FFT will
        be taken along the last two axes.

    hann_window : bool
        Whether to apply a hanning window to the image before taking the FFT.
        Default: False

    upsample_factor : int
        The factor by which to upsample the data during the FFT process. This
        operation is done by padding the image(s) with zeros after applying
        the (optional) Hanning window. Hanning windowing is recommended to
        avoid artifacts if upsampling. For 4D STEM datasets, using large
        factors can be very slow and may max out available memory.
    abs_val : bool
        Whether to take return the absolute value of the FFT (if True). If
        False, returns the complex-valued FFT.
        Default: True

    preshift : bool
        Whether to apply fftshift prior to taking the FFT. Needed for imaginary
        cepstrum.
        Default: False

    postshift : bool
        Whether to apply fftshift after taking the FFT. Commonly used to
        display the zero frequency at the center.
        Default : True

    Returns
    -------
    fft : ndarray
        FFT amplitude of image after cropping to largest possible square image.

    """

    h, w = image.shape[-2:]
    m = min(h, w)
    U = m/2
    ndim = len(image.shape)

    if h != w:
        image_square = image[...,
                             int(h/2-U): int(h/2+U),
                             int(w/2-U): int(w/2+U)]
    else:
        image_square = image

    if type(hann_window) is bool:
        if hann_window:
            hann = hann_2d(m)[*([None]*(ndim-2)), ...]
            image_square *= hann

    elif type(hann_window) is np.ndarray:
        image_square *= hann_window

    if upsample_factor is not None:
        if upsample_factor > 1:
            print('upsampling... may take a while longer.')
            upsample_factor = int(upsample_factor)
            pad = int(m/2 * (upsample_factor - 1))
            padding = ((0, 0),)*(ndim - 2) + ((pad, pad),)*2
            image_square = np.pad(image_square, padding)
            print(image_square.shape)

    if preshift:
        fft = fft2(fftshift(image_square, axes=(-2, -1)))
    else:
        fft = fft2(image_square)

    if postshift:
        fft = fftshift(fft, axes=(-2, -1))

    if abs_val:
        fft = np.abs(fft)

    return fft


def hann_2d(dim):
    """Creates a square 2D Hann window without square artifact generated by
    the common method.

    The resulting Hann function is round

    Parameters
    ----------
    dim : int
        The dimension of the Hann window to be created.

    Returns
    -------
    hann : 2d array
        The Hann window.

    """
    inds = np.arange(dim)

    origin = np.array([dim/2] * 2, ndmin=3).T

    r = np.linalg.norm(
        np.array(np.meshgrid(inds, inds)) - origin,
        axis=0
    ) * 2*np.pi / dim

    hann = np.where(r > np.pi, 0, np.cos(r) + 1) / 2

    return hann


def get_fft_pixel_size(image, pixel_size):
    """Gets FFT pixel size for a real-space image.

    Parameters
    ----------
    image : 2D array
        The image. If not square, the smaller dimension will be used.

    pixel_size : scalar
        The pixel size of the real space image.

    Returns
    -------
    reciprocal_pixel_size : scalar
        Size of a pixel in an FFT of the image (assuming the image is first
        cropped to the largest square).

    """
    h, w = image.shape
    m = (min(h, w) // 2) * 2

    reciprocal_pixel_size = (pixel_size * m) ** -1

    return reciprocal_pixel_size


def cft(xy, im):
    """
    Calculate value of the continuous Fourier tansform of an array at arbitrary
    point.

    Parameters
    ----------
    xy : 2-tuple of scalars
        The x, y coordinates in the Fourier transform  that are to be sampled.
        x is the horizontal axis, y the vertical (with positive increasing
        down the frame).

    im : 2d array
        The array from which the Fourier transform is to be caluclated.

    Returns
    -------
    val : scalar
        Value of CFT at the point xy
    """

    x, y = xy
    h, w = im.shape
    j = np.arange(h)[:, None]
    k = np.arange(w)[None, :]

    x += w/2  # because the coordinates are zero-centered
    y += h/2

    val = np.sum((im * (np.exp(-2 * np.pi * 1j * j * y / h) @
                        np.exp(-2 * np.pi * 1j * k * x / w))))

    return val


def cepstrum(data, method='power', upsample_factor=1):
    """
    Calculate the exit wave cepstrum of a dataset.

    Parameters
    ----------
    data : ndarray
        The array containing diffraction patterns from which to calculate the
        cepstrum. The last two dimensions must be the diffraction patterns and,
        ideally, they should be square.

    method : str
        The cepstrum type to return: 'power', 'imaginary'.

    upsample_factor : int
        Factor by which to upsample the cepstrum relative to the input data.

    Returns
    -------
    cepstrum : ndarray
        The cepstral transform of the data.
    """

    minval = np.array(np.min(data, axis=(-2, -1)))[..., None, None]

    if method == 'power':
        cepstrum = fft_square(
            np.log(data - minval + 1),
            hann_window=True,
            upsample_factor=upsample_factor,
            abs_val=True,
            preshift=False,
        )

    elif method == 'imaginary':
        cepstrum = np.imag(fft_square(
            np.log(data - minval + 1),
            hann_window=True,
            upsample_factor=upsample_factor,
            abs_val=False,
            preshift=True,
        ))

    elif method == 'complex':
        cepstrum = fft_square(
            np.log(data - minval + 1),
            hann_window=True,
            upsample_factor=upsample_factor,
            abs_val=False,
            preshift=True,
        )

    else:
        raise Exception("'method' must be 'power', 'imagninary' " +
                        "or 'complex'.")

    return cepstrum


def ewpc_obj_fn(xy, log_dp):
    """
    Objective function for EWPC peak finding.

    Parameters
    ----------
    xy : 2-tuple of scalars
        The x, y coordinates in the Fourier transform  that are to be sampled.
        x is the horizontal axis, y the vertical (with positive increasing
        down the frame).

    log_dp : 2d array
        The array from which the Fourier transform is to be caluclated.

    Returns
    -------
    value : scalar
        Negative of the magnitude of the CFT. Allows finding the minimum of
        the inverted EWPC peak
    """

    return -np.abs(cft(xy, log_dp))


def find_ewpc_peak(
        p0,
        log_dp,
        bound_dist,
):
    """
    Find a peak in an EWPC pattern.

    Parameters
    ----------
    p0 : 2-tuple of scalars
        Initial guess for the x, y coordinates of the EWPC peak.

    log_dp : 2d array
        Log of the array from which the EWPC is to be calculated, with Hann
        window applied.

    bound_dist : scalar
        The distance in x and y from p0 bounding the allowed solution.

    Returns
    -------
    params : 2-tuple of scalars
        The resulting peak location.
    """

    bounds = ((p0[0] - bound_dist, p0[0] + bound_dist),
              (p0[1] - bound_dist, p0[1] + bound_dist))

    params = minimize(
        ewpc_obj_fn,
        p0,
        args=log_dp,
        bounds=bounds,
        method='L-BFGS-B',
    ).x

    return params


def ewic_peak_obj_fn(xy, log_dp, sign=1):
    """
    Objective function for EWIC peak finding.

    Parameters
    ----------
    xy : 2-tuple of scalars
        The x, y coordinates in the Fourier transform  that are to be sampled.
        x is the horizontal axis, y the vertical (with positive increasing
        down the frame).

    log_dp : 2d array
        The array from which the Fourier transform is to be caluclated.

    sign : 1 or -1
        The sign of the peak to be fit. i.e. whether it is the postive or
        negative EWIC peak of the dipole being measured.

    Returns
    -------
    value : scalar
        Negative of the magnitude of the CFT. Allows finding the minimum of
        the inverted EWPC peak
    """

    return -np.imag(cft(xy, log_dp)) * np.sign(sign)


def find_ewic_peak(
        p0,
        log_dp,
        bound_dist,
        sign
):
    """
    Find a peak in an EWPC pattern.

    Parameters
    ----------
    p0 : 2-tuple of scalars
        Initial guess for the x, y coordinates of the EWPC peak.

    log_dp : 2d array
        Log of the array from which the EWPC is to be calculated, with Hann
        window applied.

    bound_dist : scalar
        The distance in x and y from p0 bounding the allowed solution.

    sign : 1 or -1
        The sign of the peak to be fit. i.e. whether it is the postive or
        negative EWIC peak of the dipole being measured.

    Returns
    -------
    params : 2-tuple of scalars
        The resulting peak location.
    """

    bounds = ((p0[0] - bound_dist, p0[0] + bound_dist),
              (p0[1] - bound_dist, p0[1] + bound_dist))

    params = minimize(
        ewic_peak_obj_fn,
        p0,
        args=(log_dp, sign),
        bounds=bounds,
        method='L-BFGS-B',
    ).x

    return params


# def fourier_center(image, x0y0):
#     """
#     Center a point in an image.

#     This function shifts the image to center the specified coordinate at the
#     pixel (h//2, w//2). This is the correct convention so that if fftshift is
#     applied, the centered point will be shifted to the (0, 0) pixel.
#     Additionally, the function works for image stacks or (higher dimension)
#     by appling the shift to the last two axes only.

#     Parameters
#     ----------
#     image : ndarray
#         The image to center.

#     x0y0 : 2-tuple
#         The (x, y) coordinates of the image point to be centered.

#     Returns
#     -------
#     im_cent : ndarray
#         The centered image.
#     """

#     h, w = image.shape[-2:]

#     x0, y0 = np.array([w, h]) / 2 - np.array(x0y0)
#     # print(x0, y0)

#     shift = [0 for _ in range(len(image.shape)-2)] + [y0, x0]

#     hann = hann_2d(h)

#     im_cent = np.abs(ifft2(
#         fourier_shift(fft2(image, axes=(-2, -1)), shift),
#         axes=(-2, -1)))

#     # crop = np.ceil(np.max(np.abs([x0, y0]))).astype(int)

#     # im_cent = im_cent[..., crop:-crop, crop:-crop]

#     return im_cent


def fourier_center(data, center, coords=None, hann_window=True):
    """
    My version... may be slower.
    Center a point in an image.

    This function shifts the image to center the specified coordinate at the
    pixel (h//2, w//2). This is the correct convention so that if fftshift is
    applied, the centered point will be shifted to the (0, 0) pixel.
    Additionally, the function works for image stacks or (higher dimension)
    by appling the shift to the last two axes only.

    Parameters
    ----------
    image : ndarray
        The image to center.

    center : 2-tuple
        The (x, y) coordinates of the image point to be centered.

    coords : array of shape (2, m, n)
        The coordinates of pixels in unshifted FFT space with the components in
        (x, y) order along the first axis. If None, function will calculate the
        coordinates. Only recommended to pass coordinates if calling many times
        to avoid calculating repeatedly.
        Default: None.

    hann_window : bool
        Whether to apply a Hann window before each FFT operation. Significantly
        recudes intensity outside the middle of the dataset.

    Returns
    -------
    im_cent : ndarray
        The centered image.
    """

    # Initial setup
    h, w = data.shape[-2:]

    if coords is None:
        m = data.shape[-1] // 2
        print(m)
        coords = fftshift(
            np.flip((np.indices(data.shape[-2:])) - m),
            axes=(-2, -1)
        )

    if hann_window:
        window = hann_2d(h)
    else:
        window = np.ones((h, w))

    shiftxy = np.array([w, h]) / 2 - np.array(center)

    # Shift the image
    cF = fft2(data * window)

    phase = np.exp(
        -1j * 2 * np.pi * (coords[0] * shiftxy[0] + coords[1] * shiftxy[1]) / h
    )

    datashifted = np.abs(ifft2(fftshift(window) * cF * phase))

    return datashifted


def ewic_center_obj_fn(xy, dp, coords):
    """
    Objective function for
    This function finds the center of a diffraction pattern by determining
    the Fourier shift that produces the smallest residual difference between
    the shifted pattern and its left-right & up-down flips. It works best for
    diffraction patterns that are nearly centered, nearly on-zone and with a
    relatively dominant direct beam.

    Parameters
    ----------
    dp : ndarray
        The diffraction pattern.

    xy0 : 2-tuple or None
        The (x, y) initial guess for the diffraction pattenr center. If None,
        takes the center of mass of the entire pattern as the initial guess.

    coords : ndarray
        The (x, y) coordinates for each pixel in the dp. If None, will be
        calculated by the funciton.
        Default: None.

    Returns
    -------
    ewic_ss : Sum of squared
        The centered image.
    """

    if coords is None:
        m = dp.shape[-1] // 2
        coords = fftshift(
            np.flip((np.indices(dp.shape[-2:])) - m),
            axes=(-2, -1)
        )

    dp_cent = fourier_center(dp, xy, coords)

    ewcc = cepstrum(dp_cent, method='complex')
    ewic = np.imag(ewcc)
    ewpc = np.abs(ewcc)

    ewpc_sm = gaussian_filter(ewpc, 1)

    mask = np.where(ewpc_sm > np.std(ewpc_sm)*0.5, 1, 0)

    ewic_ss = np.sum((ewic * mask)**2)

    return ewic_ss


def find_dp_center_ewicmin(dp, xy0=None, coords=None):
    """
    Find the center of a diffraction pattern.

    This function finds the center of a diffraction pattern by determining
    the Fourier shift that produces the smallest residual difference between
    the shifted pattern and its left-right & up-down flips. It works best for
    diffraction patterns that are nearly centered, nearly on-zone and with a
    relatively dominant direct beam.

    Parameters
    ----------
    dp : ndarray
        The diffraction pattern.

    xy0 : 2-tuple or None
        The (x, y) initial guess for the diffraction pattenr center. If None,
        takes the center of mass of the entire pattern as the initial guess.

    coords : ndarray
        The (x, y) coordinates for each pixel in the dp. If None, will be
        calculated by the funciton.
        Default: None.

    Returns
    -------
    xy_cent : 2-tuple
        The center of the diffraction pattern.
    """

    if xy0 is None:
        xy0 = np.flip(center_of_mass(dp))

    if coords is None:
        m = dp.shape[-1] // 2
        coords = fftshift(
            np.flip((np.indices(dp.shape[-2:])) - m),
            axes=(-2, -1)
        )

    fit = minimize(
        ewic_center_obj_fn,
        xy0,
        args=(dp, coords),
        method='Powell',
    )
    xy_cent = fit.x

    return xy_cent


def center_dp_ewic(
        dp,
        xy0,
        coords=None,
        return_center=False,
        nearest_pixel=False,
        hann_window=True,
):
    """
    Center an individual diffraction pattern by minimizing the imaginary
    cepstrum.

    Parameters
    ----------
    dp : 2d array
        The diffraction pattern.

    xy0 : array like of shape (2,
        The (x, y) initial guess for the diffraction pattern center.

    coords : ndarray
        The (x, y) coordinates for each pixel in the dp. If None, will be
        calculated by the funciton.
        Default: None.

    return_center : bool
        If true, will return the centered DP and the original measured center.
        If false, only returns the centered DP.
        Default: False.

    hann_window : bool
        Whether to apply a Hann window before each FFT operation when doing the
        final centering. Significantly recudes intensity outside the middle of
        the dataset.

    Returns
    -------
    dp_cent : 2d array
        The centered diffraction pattern.
    """

    if coords is None:
        m = dp.shape[-1] // 2
        coords = fftshift(
            np.flip((np.indices(dp.shape[-2:])) - m),
            axes=(-2, -1)
        )

    if nearest_pixel:
        cent = np.around(find_dp_center_ewicmin(dp, xy0, coords))

    else:
        cent = find_dp_center_ewicmin(dp, xy0, coords)

    dp_cent = fourier_center(dp, cent, coords, hann_window)

    if return_center:
        return dp_cent, cent
    else:
        return dp_cent


def center_dataset_ewic(
        data,
        xy0,
        return_centers=False,
        nearest_pixel=False,
        hann_window=True
):
    """
    Center diffraction patterns in an nD STEM dataset by minimizing the
    imaginary cepstrum for each pattern individually.

    Parameters
    ----------
    data : ndarray
        The dataset with the last two dimensions being the diffraction axes.

    xy0 : array like of shape (2,)
        The (x, y) initial guess for the diffraction pattern center.

    return_centers : bool
        If true, will return the centered DPs and the original measured
        centers. If false, only returns the centered DPs.
        Default: False.

    hann_window : bool
        Whether to apply a Hann window before each FFT operation. Significantly
        recudes intensity outside the middle of the dataset.

    Returns
    -------
    data_cent : ndarray
        The centered dataset.
    """

    n_jobs = psutil.cpu_count(logical=True)

    m = data.shape[-1] // 2
    coords = fftshift(
        np.flip((np.indices(data.shape[-2:])) - m),
        axes=(-2, -1)
    )

    results = Parallel(n_jobs=n_jobs)(
        delayed(center_dp_ewic)(
            dp, xy0, coords, return_centers, nearest_pixel, hann_window,
        ) for dp in tqdm(data.reshape(-1, *data.shape[-2:]))
    )

    if return_centers:
        centers = np.array([cent for _, cent in results]
                           ).reshape((*data.shape[:2], 2))
        results = [dp for dp, _ in results]

    data_cent = np.array(results).reshape(data.shape)

    if return_centers:
        return data_cent, centers
    else:
        return data_cent
